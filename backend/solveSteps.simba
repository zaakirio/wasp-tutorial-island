{$DEFINE WT_SOLVESTEPS}

procedure SolveTalkToStep(var step: TStep);
var
  npcArr: TRSNPCV2Array;
begin
  step.actionSucceeded := False;

  if step.coordinate = [0,0] then step.coordinate := Map.Walker.Position();

  if step.NPC_target.Coordinates = [] then
  begin
    npcArr := NPCs.GetAll(step.NPC_name);
    if Length(npcArr) = 0 then
    begin
      WriteLn('[SolveTalkToStep] No NPCs found for: ', step.NPC_name);
      Exit;
    end;
    step.NPC_target := npcArr.findNearest(step.coordinate);
    if step.NPC_target.Coordinates = [] then
    begin
      WriteLn('[SolveTalkToStep] findNearest returned no valid NPC for: ', step.NPC_name);
      Exit;
    end;
    //Debug(step.NPC_target);
    if step.colors = [] then
      step.NPC_target.Finder.Colors := [CTS2(3504679, 17, 2.17, 2.93)]
    else
      step.NPC_target.Finder.Colors := step.colors;
  end;

  if step.webwalk then
    step.actionSucceeded := step.NPC_target.WalkSelectOption([step.action],5)
  else
    step.actionSucceeded := step.NPC_target.SelectOption([step.action],5);

  if step.actionSucceeded then
    if not WaitUntil(Chat.HasContinue() or (Chat.GetChatTitle = 'Select an option'), 20, 5000) then
      step.actionSucceeded := False;

  if @step.SpecialEvent <> nil then
    step.SpecialEvent();
  if @step.CompletionCondition <> nil then
    step.completed := step.CompletionCondition()
  else
    step.completed := step.StandardCompletion();
end;

procedure SolveKillStep(var step: TStep);
var
  npcArr: TRSNPCV2Array;
begin
  step.actionSucceeded := False;

  if step.coordinate = [0,0] then step.coordinate := Map.Walker.Position();

  if step.NPC_target.Coordinates = [] then
  begin
    npcArr := NPCs.GetAll(step.NPC_name);
    if Length(npcArr) = 0 then
    begin
      WriteLn('[SolveKillStep] No NPCs found for: ', step.NPC_name);
      Exit;
    end;
    step.NPC_target := npcArr.findNearest(step.coordinate);
    if step.NPC_target.Coordinates = [] then
    begin
      WriteLn('[SolveKillStep] findNearest returned no valid NPC for: ', step.NPC_name);
      Exit;
    end;
    //Debug(step.NPC_target);
    if step.colors = [] then
      step.NPC_target.Finder.Colors := [CTS2(3504679, 17, 2.17, 2.93)]
    else
      step.NPC_target.Finder.Colors := step.colors;
  end;

  xpbar.EarnedXP();

  if step.webwalk then
  begin
    step.NPC_target.WalkSelectOption(['Attack'],5);
    if not (step.prayers = []) then Prayer.ActivatePrayer(step.prayers);
  end
  else
  begin
    if not (step.prayers = []) then Prayer.ActivatePrayer(step.prayers);
    step.NPC_target.SelectOption(['Attack'],5);
  end;

  Inventory.open();

  if not WaitUntil(Mainscreen.IsInCombat, 50,6000) then
  begin
    step.actionSucceeded := False;
  end else
  begin
    step.actionSucceeded := True;
    WriteLn('Waiting ', step.CombatTime/1000, ' seconds until out of combat');
    WaitUntil(not Mainscreen.IsInCombat, 50, step.CombatTime);

    if not (step.prayers = []) then Prayer.DisablePrayer(step.prayers);
  end;

  if not step.waitItem.IsNull then step.actionSucceeded := WaitUntil(inventory.ContainsItem(step.waitItem), 50, step.time);

  if @step.SpecialEvent <> nil then
    step.SpecialEvent();
  if @step.CompletionCondition <> nil then
    step.completed := step.CompletionCondition()
  else
    step.completed := step.StandardCompletion();
end;

procedure SolveInteractObjectStep(var step: TStep);
var
  objArr: TRSObjectV2Array;
begin
  step.actionSucceeded := False;

  if step.coordinate = [0,0] then step.coordinate := Map.Walker.Position();

  if step.objectTarget.Coordinates = [] then
  begin
    objArr := Objects.GetAll(step.objName);
    step.objectTarget := objArr.findNearestSingle(step.coordinate);
    if step.colors = [] then
      step.objectTarget.Finder.Colors := [CTS2(3504679, 17, 2.17, 2.93)]
    else
      step.objectTarget.Finder.Colors := step.colors;
  end;

  //Debug(step.objectTarget);

  try
    if step.webwalk then
      step.actionSucceeded := step.objectTarget.WalkSelectOption([step.action],5)
    else
      step.actionSucceeded := step.objectTarget.SelectOption([step.action],5);
  except WriteLn('Error has occured');
  end;

  if step.waitCoord <> [0,0] then
  begin
    step.actionSucceeded := WaitUntil(map.Position.InRange(step.waitCoord,step.waitRange),50,step.time);
    Wait(1200);
  end;
  if not step.waitItem.IsNull then step.actionSucceeded := WaitUntil(inventory.ContainsItem(step.waitItem), 50, step.time);

  if @step.SpecialEvent <> nil then
    step.SpecialEvent();
  if @step.CompletionCondition <> nil then
    step.completed := step.CompletionCondition()
  else
    step.completed := step.StandardCompletion();
end;

procedure SolveInteractInventoryStep(var step: TStep);
var
  slots: TIntegerArray;
begin
  step.actionSucceeded := False;
  if not Inventory.IsOpen() then Inventory.Open();
  if not Inventory.ContainsItem(step.item1) then Exit;

  Inventory.FindItem(step.item1, slots);
  step.actionSucceeded := Inventory.ClickSlot(slots[0], [step.action]);
  if step.actionSucceeded and (step.waitCoord <> [0,0]) then
  begin
    step.actionSucceeded := WaitUntil(map.Position.InRange(step.waitCoord,step.waitRange),50,step.time);
    Wait(1200);
  end;
  if not step.waitItem.IsNull then step.actionSucceeded := WaitUntil(inventory.ContainsItem(step.waitItem), 50, step.time);

  if @step.SpecialEvent <> nil then
    step.SpecialEvent();
  if @step.CompletionCondition <> nil then
    step.completed := step.CompletionCondition()
  else
    step.completed := step.StandardCompletion();
end;

procedure SolveConversationStep(var step: TStep);
var
  i: Variant;
  options, prev: TStringArray;
  o: TRSChatBoxOptionArray;
  str, match: String;
  sim: Single;
  chatIndex: Integer;
begin
  step.actionSucceeded := False;
  WaitUntil(chat.HasContinue,10,5000);

  step.conversation += 0;

  Writeln('Starting conversation');
  if step.savedConversation.len > 0 then
  begin
    step.savedConversation := [];
    for i in step.conversation do
    begin
      try
        chatIndex := StrToInt(i);
        Chat.ChatToNumber(chatIndex-1, step.savedConversation);
      except
        prev := Chat.GetOptions([$000000]).ToStringArray;
        step.savedConversation.Extend(prev);
        while chat.HasContinue() do
        begin
          chat.ClickContinue(False);
          WaitUntil(Chat.GetOptions([$000000]).ToStringArray <> prev, 100, 5000);
          prev := Chat.GetOptions([$000000]).ToStringArray;
          step.savedConversation.Extend(prev);
        end;
        o := Chat.GetOptions();
        options := o.ToStringArray();
        str := ToStr(i);
        match := options.FindBestMatch(str, sim);
        ChatIndex := options.Find(match);
        Chat.ChatToNumber(ChatIndex-1, step.savedConversation);
      end;
    end;
  end
  else
    for i in step.conversation do
    begin
      try
        chatIndex := StrToInt(i);
        Chat.ChatToNumber(chatIndex-1);
      except
        while chat.HasContinue() do
        begin
          chat.ClickContinue(False);
          Wait(0,700,wdLeft);
        end;
        o := Chat.GetOptions();
        options := o.ToStringArray();
        str := ToStr(i);
        match := options.FindBestMatch(str, sim);
        ChatIndex := options.Find(match);
        Chat.ChatToNumber(ChatIndex-1);
      end;
    end;

  step.actionSucceeded := True;
  if step.actionSucceeded and (step.waitCoord <> [0,0]) then
  begin
    step.actionSucceeded := WaitUntil(map.Position.InRange(step.waitCoord,step.waitRange),50,step.time);
    Wait(1200);
  end;
  if not step.waitItem.IsNull then step.actionSucceeded := WaitUntil(inventory.ContainsItem(step.waitItem), 50, step.time);

  if @step.SpecialEvent <> nil then
    step.SpecialEvent();
  if @step.CompletionCondition <> nil then
    step.completed := step.CompletionCondition()
  else
    step.completed := step.StandardCompletion();
end;

procedure SolveCombineStep(var step: TStep);
begin
  step.actionSucceeded := False;
  if not Inventory.IsOpen() then Inventory.Open();
  if not Inventory.ContainsItem(step.item1) then Exit;
  if not Inventory.ContainsItem(step.item2) then Exit;

  step.actionSucceeded := Inventory.Use(step.item1,step.item2);
  if not step.waitItem.IsNull then step.actionSucceeded := WaitUntil(inventory.ContainsItem(step.waitItem), 50, step.time);

  if @step.SpecialEvent <> nil then
    step.SpecialEvent();
  if @step.CompletionCondition <> nil then
    step.completed := step.CompletionCondition()
  else
    step.completed := step.StandardCompletion();
end;

procedure SolveWalkStep(var step: TStep);
begin
  if Map.Walker.Position = step.coordinate then
  begin
    step.actionSucceeded := True;
  end else
    Map.Walker.Ladderwalk(step.coordinate);
  WaitUntil(not Minimap.IsPlayerMoving, 50,5000);
  if step.time = 0 then step.time := 5000;

  if (step.waitCoord <> [0,0]) then
    step.actionSucceeded := WaitUntil(map.Position.InRange(step.waitCoord,step.waitRange),50,step.time)
  else
    step.actionSucceeded := WaitUntil(map.Position.InRange(step.coordinate,5),50,step.time);

  if @step.SpecialEvent <> nil then
    step.SpecialEvent();
  if @step.CompletionCondition <> nil then
    step.completed := step.CompletionCondition()
  else
    step.completed := step.StandardCompletion();
end;

procedure SolveWaitStep(var step: TStep);
begin
  Wait(step.time, step.time + 600);
  step.actionSucceeded := True;
  if not step.waitItem.IsNull then step.actionSucceeded := WaitUntil(inventory.ContainsItem(step.waitItem), 50, step.time);
  if @step.SpecialEvent <> nil then
    step.SpecialEvent();
  if @step.CompletionCondition <> nil then
    step.completed := step.CompletionCondition()
  else
    step.completed := step.StandardCompletion();
end;

procedure SolveClickTileStep(var step: TStep);
begin
  step.actionSucceeded := Map.ClickTile(step.coordinate, step.action);
  if step.actionSucceeded and (step.waitCoord <> [0,0]) then
  begin
    step.actionSucceeded := WaitUntil(map.Walker.Position.InRange(step.waitCoord,step.waitRange),50,step.time);
    Wait(1200);
  end;
  if step.actionSucceeded and not step.waitItem.IsNull then step.actionSucceeded := WaitUntil(inventory.ContainsItem(step.waitItem), 50, step.time);
  if @step.SpecialEvent <> nil then
    step.SpecialEvent();
  if @step.CompletionCondition <> nil then
    step.completed := step.CompletionCondition()
  else
    step.completed := step.StandardCompletion();
end;

procedure SolveCustomStep(var step: TStep);
begin
  step.actionSucceeded := True;
  if step.actionSucceeded and not step.waitItem.IsNull then step.actionSucceeded := WaitUntil(inventory.ContainsItem(step.waitItem), 50, step.time);
  if @step.SpecialEvent <> nil then
    step.SpecialEvent();
  if @step.CompletionCondition <> nil then
    step.completed := step.CompletionCondition()
  else
    step.completed := step.StandardCompletion();
end;
